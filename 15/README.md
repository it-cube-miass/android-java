Если предыдущие несколько глав достигли своей цели, теперь должна быть понятна важность сохранения и восстановления состояния пользовательского интерфейса в определенные моменты жизненного цикла действия. 

В этой главе мы расширим приложение, созданного в предыдущей главе, чтобы продемонстрировать шаги, связанные с сохранением и восстановлением состояния, когда активность уничтожается и воссоздается. 

Ключевой компонент сохранения и восстановления динамического состояния включает использование класса *Bundle* из Android SDK.

## Сохранение динамического состояния
Активность, как мы уже узнали, дает возможность сохранять информацию о динамическом состоянии через реализацию метода *onSaveInstanceState()*, который вызывает система. В качестве аргумента методу передается ссылка на объект *Bundle*, в котором необходимо будет сохранить любые динамические данные. Затем объект *Bundle* сохраняется системой времени выполнения от имени активности и впоследствии передается в качестве аргумента методам *onCreate()* и *onRestoreInstanceState()* активности, когда они вызываются. В этих методах данные могут быть извлечены из объекта *Bundle* и использованы для восстановления состояния активности.

## Сохранение состояния UI по умолчанию
В предыдущей главе диагностический вывод приложения *StateChange* показал, что активность проходит через ряд изменений состояния, когда устройство, на котором она работает, поворачивается, вызвая изменение ориентации.

Запустите приложение *StateChange* еще раз, только на этот раз введите текст в поле *EditText* перед поворотом устройства. После поворота в окне *Logcat* должна появиться следующая последовательность:
```txt
onPause 
onStop 
onSaveInstanceState 
onDestroy 
onCreate 
onStart 
onRestoreInstanceState 
onResume
```
Очевидно, это привело к уничтожению и воссозданию активности. Однако текст, введенный в поле *EditText*, был сохранен. Как же это так? Ведь мы не писали какой-либо код, для сохранения и восстановления текста.

Фактически, большинство виджетов, включенных в Android SDK, уже реализуют поведение, необходимое для автоматического сохранения и восстановления состояния при перезапуске активности. Единственное требование для сохранения этого поведения - это чтобы переопределенные методы ```onSaveInstanceState()``` и ```onRestoreInstanceState()``` в активности включали вызовы эквивалентных методов суперкласса:
```java
@Override 
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState); 
} 

@Override 
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    super.onRestoreInstanceState(saveInstanceState); 
}
```
Автоматическое сохранение состояния для виджета пользовательского интерфейса можно отключить, установив свойству *saveEnabled* значение ```false```. В целях изучения, мы отключим механизм автоматического сохранения состояния для *EditText*, а затем добавим код, для ручного сохранения и восстановления состояния. (Обратите внимание, что XML можно редактировать напрямую, щелкнув вкладку *Text* в нижней части панели *Layout Editor*. Полное название этого свойства *android:saveEnabled*)

Измените свойство *saveEnabled* у *EditText* на ```false```. После, запустите приложение, введите текст и поверните устройство, чтобы убедиться, что текст больше не сохраняется и не восстанавливается.

## Класс Bundle
Для ситуаций, когда необходимо сохранить состояние за пределами функциональности по умолчанию, предоставляемой виджетами пользовательского интерфейса, класс *Bundle* предоставляет контейнер для хранения данных с использованием механизма *key-value*. Ключи принимают форму строковых значений, тогда как значения, связанные с этими ключами, могут быть в форме примитивного значения или любого объекта, реализующего интерфейс *Parcelable* из Android SDK. Широкий спектр классов уже реализует интерфейс Parcelable. Пользовательские классы можно сделать *parcelable* путем реализации набора методов, определенных в интерфейсе *Parcelable*, подробную информацию о которых можно найти в документации Android по адресу: [https://developer.android.com/reference/android/os/Parcelable.html](https://developer.android.com/reference/android/os/Parcelable.html)

Класс *Bundle* также содержит набор методов, которые можно использовать для получения и установки пар *key-value* для различных типов данных, включая как примитивные типы (*boolean*, *char*, *double* и *float*), так и объекты (такие как *Strings* и *CharSequence*). 

Отключив автоматическое сохранение текста для *EditText*, нам необходимо убедиться, что текст, введенный пользователем в поле *EditText*, сохраняется в объекте Bundle и впоследствии восстанавливается. Это будет служить демонстрацией того, как вручную сохранять и восстанавливать состояние в приложении Android, и будет достигнуто с помощью методов *putCharSequence()* и *getCharSequence()* класса *Bundle*.

## Сохранение состояния
Первым шагом надо сделать так, чтобы текст, введенный пользователем, был извлечен из компонента *EditText* в методе *onSaveInstanceState()* активности *MainActivity*, а затем сохранен в объекте *Bundle*.

Чтобы извлечь текст из объекта *EditText*, нам сначала нужно идентифицировать этот объект в пользовательском интерфейсе. Очевидно, это включает в себя устранение разрыва между Java-кодом активности (содержащимся в файле MainActivity.java) И XML-представлением пользовательского интерфейса (содержащимся в файле ресурсов activity_main.xml). Чтобы извлечь текст, введенный в компонент *EditText*, нам необходимо получить доступ к этому объекту пользовательского интерфейса.

Каждый компонент в пользовательском интерфейсе связан с уникальным идентификатором. По умолчанию инструмент *Layout Editor* создает идентификатор для вновь добавленного компонента из типа объекта. Если в макете содержится несколько представлений одного и того же типа, за именем типа следует порядковый номер (хотя разработчик может и должен изменить его на что-то более значимое). Проверив панель *Component Tree*, можно увидеть, компоненту *EditText* назначен идентификатор ```editText```

![рис. 15-1](assets/15-1.png)

Зная идентификатор, мы можем получить ссылку на виджет из кода активности: 
```java
final EditText editText = findViewById (R.id.editText); 
```
Теперь мы можем получить текст, содержащийся в editText, с помощью метода *getText()*:
```java
CharSequence userText = editText.getText();
```
Наконец, мы можем сохранить текст, используя метод *putCharSequence()* объекта *Bundle*, передав ключ (это может быть любое строковое значение, мы объявим его как ```savedText```) и объект userText в качестве второго аргумента: 
```java
outState.putCharSequence("savedText", userText); 
```
Объединение всего этого дает нам модифицированный метод *onSaveInstanceState()* в файле MainActivity.java:
```java
protected void onSaveInstanceState(Bundle outState) { 
    super.onSaveInstanceState(outState);
    Log.i(TAG, "onSaveInstanceState"); 
    
    final EditText editText = findViewById(R.id.editText); 
    CharSequence userText = editText.getText(); 
    outState.putCharSequence("savedText", userText); 
} 
```
Теперь, когда были сделаны шаги по сохранению состояния, необходимо обеспечить его восстановления при необходимости.

## Востановление состояния
Сохраненное динамическое состояние можно восстановить в тех методах жизненного цикла, которым передается объект *Bundle* в качестве параметра. Это оставляет разработчику выбор: использовать *onCreate()* или *onRestoreInstanceState()*. Используемый метод будет зависеть от характера активности. В случаях, когда состояние лучше востановить после выполнения инициализации активности, более подходит метод *onRestoreInstanceState()*. Мы добавим код в метод *onRestoreInstanceState()* для извлечения сохраненного состояния из *Bundle* с помощью ключа ```savedText```. Затем мы cможем отобразить текст в компоненте editText, используя метод объекта *setText()*:
```java
@Override
protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
    super.onRestoreInstanceState(savedInstanceState);
    Log.i(TAG, "onRestoreInstanceState");

    final EditText editText = findViewById(R.id.editText);
    CharSequence userText = savedInstanceState.getCharSequence("savedText");
    editText.setText(userText);
}
```

## Тестирование приложения
Все, что остается, - это снова собрать и запустить приложение *StateChange*. После запуска коснитесь компонента *EditText* и введите текст, а после поверните устройство в другую ориентацию. Убедившись, что код работает, как ожидалось, закомментируйте вызовы *super.onSaveInstanceState()* и *super.onRestoreInstanceState()* из двух методов, повторно запустите приложение и обратите внимание, что текст все еще сохраняется после ротации устройства. Система сохранения и восстановления по умолчанию была заменена специальной реализацией, что дает возможность динамически и выборочно сохранять и восстанавливать состояние внутри активности.

## Резюме
Сохранение и восстановление динамического состояния в приложении Android - это просто вопрос написания необходимого кода в соответствующих методах жизненного цикла. Для большинства виджетов пользовательского интерфейса это автоматически обрабатывается суперклассом Activity. В других случаях это обычно состоит из извлечения значений и настроек в методе *onSaveInstanceState()* и сохранения данных в виде пар *key-value* в объекте *Bundle*, переданном активности системой. 

Состояние можно восстановить в методах активности *onCreate()* или *onRestoreInstanceState()*, путем извлечения значений из объекта *Bundle* и обновления активности на основе сохраненных значений.
